// Code generated by protoc-gen-gohttp. DO NOT EDIT.
// source: contracts/service.proto

package contracts

import (
	context "context"
	gin "github.com/gin-gonic/gin"
	protojson "google.golang.org/protobuf/encoding/protojson"
	ioutil "io/ioutil"
	contracts "prototodo/pkg/domain/contracts"
)

const InternalContextKey = "inCxt"

var protomarsh = protojson.MarshalOptions{EmitUnpopulated: true}

// Tasks
type TasksHTTPServer interface {
	// - Commands
	Create(context.Context, *contracts.CreateTaskCommand) (*contracts.TaskEvent, error)
	Delete(context.Context, *contracts.DeleteTaskCommand) (*contracts.TaskEvent, error)
	Update(context.Context, *contracts.UpdateTaskCommand) (*contracts.TaskEvent, error)
	// Update existing task state to progress
	Progress(context.Context, *contracts.ProgressTaskCommand) (*contracts.TaskEvent, error)
	// Update existing task to complete
	Complete(context.Context, *contracts.CompleteTaskCommand) (*contracts.TaskEvent, error)
	// Query for existing tasks
	ListQuery(context.Context, *contracts.ListTasksQuery) (*contracts.TaskEntityList, error)
}
type tasks struct {
	app TasksHTTPServer
}

// creates a new task
func (p *tasks) create(ctx *gin.Context) {
	body := contracts.CreateTaskCommand{}
	raw, err := ioutil.ReadAll(ctx.Request.Body)
	if err != nil {
		ctx.Error(err)
		return
	}
	protojson.Unmarshal(raw, &body)
	var c context.Context
	if v, ok := ctx.Get(InternalContextKey); ok {
		c, _ = v.(context.Context)
	}
	if c == nil {
		c = ctx
	}
	res, err := p.app.Create(
		c,
		&body,
	)
	if err != nil {
		ctx.Error(err)
		return
	}
	resraw, err := protomarsh.Marshal(res)
	if err != nil {
		ctx.Error(err)
		return
	}
	ctx.Status(200)
	ctx.Header("Content-Type", "application/json")
	_, err = ctx.Writer.Write(resraw)
	if err != nil {
		ctx.Error(err)
		return
	}
}

// deletes an existing task
func (p *tasks) delete(ctx *gin.Context) {
	body := contracts.DeleteTaskCommand{}
	raw, err := ioutil.ReadAll(ctx.Request.Body)
	if err != nil {
		ctx.Error(err)
		return
	}
	protojson.Unmarshal(raw, &body)
	var c context.Context
	if v, ok := ctx.Get(InternalContextKey); ok {
		c, _ = v.(context.Context)
	}
	if c == nil {
		c = ctx
	}
	res, err := p.app.Delete(
		c,
		&body,
	)
	if err != nil {
		ctx.Error(err)
		return
	}
	resraw, err := protomarsh.Marshal(res)
	if err != nil {
		ctx.Error(err)
		return
	}
	ctx.Status(200)
	ctx.Header("Content-Type", "application/json")
	_, err = ctx.Writer.Write(resraw)
	if err != nil {
		ctx.Error(err)
		return
	}
}

// updates an existing task
func (p *tasks) update(ctx *gin.Context) {
	body := contracts.UpdateTaskCommand{}
	raw, err := ioutil.ReadAll(ctx.Request.Body)
	if err != nil {
		ctx.Error(err)
		return
	}
	protojson.Unmarshal(raw, &body)
	var c context.Context
	if v, ok := ctx.Get(InternalContextKey); ok {
		c, _ = v.(context.Context)
	}
	if c == nil {
		c = ctx
	}
	res, err := p.app.Update(
		c,
		&body,
	)
	if err != nil {
		ctx.Error(err)
		return
	}
	resraw, err := protomarsh.Marshal(res)
	if err != nil {
		ctx.Error(err)
		return
	}
	ctx.Status(200)
	ctx.Header("Content-Type", "application/json")
	_, err = ctx.Writer.Write(resraw)
	if err != nil {
		ctx.Error(err)
		return
	}
}

// update state of existing task to progress
func (p *tasks) progress(ctx *gin.Context) {
	body := contracts.ProgressTaskCommand{}
	raw, err := ioutil.ReadAll(ctx.Request.Body)
	if err != nil {
		ctx.Error(err)
		return
	}
	protojson.Unmarshal(raw, &body)
	var c context.Context
	if v, ok := ctx.Get(InternalContextKey); ok {
		c, _ = v.(context.Context)
	}
	if c == nil {
		c = ctx
	}
	res, err := p.app.Progress(
		c,
		&body,
	)
	if err != nil {
		ctx.Error(err)
		return
	}
	resraw, err := protomarsh.Marshal(res)
	if err != nil {
		ctx.Error(err)
		return
	}
	ctx.Status(200)
	ctx.Header("Content-Type", "application/json")
	_, err = ctx.Writer.Write(resraw)
	if err != nil {
		ctx.Error(err)
		return
	}
}

// update state of existing task to complete
func (p *tasks) complete(ctx *gin.Context) {
	body := contracts.CompleteTaskCommand{}
	raw, err := ioutil.ReadAll(ctx.Request.Body)
	if err != nil {
		ctx.Error(err)
		return
	}
	protojson.Unmarshal(raw, &body)
	var c context.Context
	if v, ok := ctx.Get(InternalContextKey); ok {
		c, _ = v.(context.Context)
	}
	if c == nil {
		c = ctx
	}
	res, err := p.app.Complete(
		c,
		&body,
	)
	if err != nil {
		ctx.Error(err)
		return
	}
	resraw, err := protomarsh.Marshal(res)
	if err != nil {
		ctx.Error(err)
		return
	}
	ctx.Status(200)
	ctx.Header("Content-Type", "application/json")
	_, err = ctx.Writer.Write(resraw)
	if err != nil {
		ctx.Error(err)
		return
	}
}

// query all existing tasks
func (p *tasks) listQuery(ctx *gin.Context) {
	body := contracts.ListTasksQuery{}
	raw, err := ioutil.ReadAll(ctx.Request.Body)
	if err != nil {
		ctx.Error(err)
		return
	}
	protojson.Unmarshal(raw, &body)
	var c context.Context
	if v, ok := ctx.Get(InternalContextKey); ok {
		c, _ = v.(context.Context)
	}
	if c == nil {
		c = ctx
	}
	res, err := p.app.ListQuery(
		c,
		&body,
	)
	if err != nil {
		ctx.Error(err)
		return
	}
	resraw, err := protomarsh.Marshal(res)
	if err != nil {
		ctx.Error(err)
		return
	}
	ctx.Status(200)
	ctx.Header("Content-Type", "application/json")
	_, err = ctx.Writer.Write(resraw)
	if err != nil {
		ctx.Error(err)
		return
	}
}
func RegisterTasksHTTPServer(
	grp *gin.RouterGroup,
	srv TasksHTTPServer,
) {
	ctrl := tasks{app: srv}
	grp.POST("/commands/createTask", ctrl.create)
	grp.POST("/commands/deleteTask", ctrl.delete)
	grp.POST("/commands/updateTask", ctrl.update)
	grp.POST("/commands/progressTask", ctrl.progress)
	grp.POST("/commands/completeTask", ctrl.complete)
	grp.POST("/queries/listTasks", ctrl.listQuery)
}

// Quotes
type QuotesHTTPServer interface {
	// Get a quote
	Get(context.Context, *contracts.GetQuoteQuery) (*contracts.QuoteData, error)
	Create(context.Context, *contracts.CreateQuoteCommand) (*contracts.QuoteData, error)
}
type quotes struct {
	app QuotesHTTPServer
}

// get a random quote
func (p *quotes) get(ctx *gin.Context) {
	body := contracts.GetQuoteQuery{}
	raw, err := ioutil.ReadAll(ctx.Request.Body)
	if err != nil {
		ctx.Error(err)
		return
	}
	protojson.Unmarshal(raw, &body)
	var c context.Context
	if v, ok := ctx.Get(InternalContextKey); ok {
		c, _ = v.(context.Context)
	}
	if c == nil {
		c = ctx
	}
	res, err := p.app.Get(
		c,
		&body,
	)
	if err != nil {
		ctx.Error(err)
		return
	}
	resraw, err := protomarsh.Marshal(res)
	if err != nil {
		ctx.Error(err)
		return
	}
	ctx.Status(200)
	ctx.Header("Content-Type", "application/json")
	_, err = ctx.Writer.Write(resraw)
	if err != nil {
		ctx.Error(err)
		return
	}
}

// get a random quote
func (p *quotes) create(ctx *gin.Context) {
	body := contracts.CreateQuoteCommand{}
	raw, err := ioutil.ReadAll(ctx.Request.Body)
	if err != nil {
		ctx.Error(err)
		return
	}
	protojson.Unmarshal(raw, &body)
	var c context.Context
	if v, ok := ctx.Get(InternalContextKey); ok {
		c, _ = v.(context.Context)
	}
	if c == nil {
		c = ctx
	}
	res, err := p.app.Create(
		c,
		&body,
	)
	if err != nil {
		ctx.Error(err)
		return
	}
	resraw, err := protomarsh.Marshal(res)
	if err != nil {
		ctx.Error(err)
		return
	}
	ctx.Status(200)
	ctx.Header("Content-Type", "application/json")
	_, err = ctx.Writer.Write(resraw)
	if err != nil {
		ctx.Error(err)
		return
	}
}
func RegisterQuotesHTTPServer(
	grp *gin.RouterGroup,
	srv QuotesHTTPServer,
) {
	ctrl := quotes{app: srv}
	grp.POST("/queries/getQuote", ctrl.get)
	grp.POST("/commands/createQuote", ctrl.create)
}
